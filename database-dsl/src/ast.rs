use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

/// The kind of a identifier.
#[derive(Debug, Clone, Copy)]
pub enum TypeKind<'a> {
    CustomId,
    IncrementalId(&'a IncrementalId),
    InternedId(&'a InterningTable),
    Enum,
    RustType,
}

impl<'a> TypeKind<'a> {
    pub fn is_custom_id(&self) -> bool {
        match self {
            TypeKind::CustomId => true,
            _ => false,
        }
    }
}

/// A custom ID (most likely some ID taken directly from the Rust compiler).
pub struct CustomId {
    pub name: syn::Ident,
    pub typ: syn::Type,
    pub items: Vec<syn::Item>,
}

/// A constant of the incremental ID.
#[derive(Debug)]
pub struct Constant {
    pub name: syn::Ident,
    /// **NOTE:** The constant value must be unique and from the range
    /// `0..IncrementalId.constants.len()`.
    pub value: syn::Lit,
}

impl Constant {
    pub fn get_getter_name(&self) -> syn::Ident {
        syn::Ident::new(
            &format!("get_{}", self.name).to_lowercase(),
            self.name.span(),
        )
    }
}

/// An identifier that is incremented each time an object is created.
#[derive(Debug)]
pub struct IncrementalId {
    pub name: syn::Ident,
    pub typ: syn::Type,
    /// Some IDs have special values.
    pub constants: Vec<Constant>,
}

impl IncrementalId {
    pub fn get_field_name(&self) -> syn::Ident {
        syn::Ident::new(&format!("{}s", self.name).to_lowercase(), self.name.span())
    }
    pub fn get_generator_fn_name(&self) -> syn::Ident {
        syn::Ident::new(
            &format!("get_fresh_{}", self.name).to_lowercase(),
            self.name.span(),
        )
    }
    pub fn get_default_value(&self) -> syn::LitInt {
        syn::LitInt::new(&self.constants.len().to_string(), self.name.span())
    }
}

/// An identifier used as a key for an interning table.
#[derive(Debug, Hash)]
pub struct InternedId {
    pub name: syn::Ident,
    pub typ: syn::Type,
}

/// An interning table for a specific type.
///
/// Note: the implementation assumes that if values are equal (by the definition of `==`),
/// then the generates keys should also be the same.
#[derive(Debug, Hash)]
pub struct InterningTable {
    pub name: syn::Ident,
    pub key: InternedId,
    pub value: syn::Type,
}

impl InterningTable {
    pub fn get_registration_function_name(&self) -> syn::Ident {
        let mut name = String::from("register_");
        for c in self.name.to_string().chars() {
            if c.is_uppercase() {
                name.push('_');
                name.extend(c.to_lowercase());
            } else {
                name.push(c);
            }
        }

        syn::Ident::new(&name, self.name.span())
    }
    pub fn get_key_type(&self) -> syn::Type {
        syn::Type::Path(syn::TypePath {
            qself: None,
            path: self.key.name.clone().into(),
        })
    }
    pub fn get_hash(&self) -> u64 {
        let mut state = DefaultHasher::new();
        self.hash(&mut state);
        state.finish()
    }
}

/// A definition of an enum.
pub struct Enum {
    pub item: syn::ItemEnum,
    /// A default variant of the enum.
    pub default: syn::Ident,
}

/// A relation parameter with types.
#[derive(Hash)]
pub struct RelationParameter {
    pub name: syn::Ident,
    pub typ: syn::Type,
    pub is_autogenerated: bool,
}

#[derive(Hash)]
pub struct RelationKey {
    pub source: Vec<syn::Ident>,
    pub target: Option<syn::Ident>,
}

/// A Datalog relation.
#[derive(Hash)]
pub struct Relation {
    pub name: syn::Ident,
    pub parameters: Vec<RelationParameter>,
    /// If `key` is Some, then the listed parameters should be used as a key when
    /// merging databases. That is, any duplicate entries having the same `key.source`
    /// should be dropped and `key.target` should be remapped.
    pub key: Option<RelationKey>,
}

impl Relation {
    pub fn get_registration_function_name(&self) -> syn::Ident {
        syn::Ident::new(&format!("register_{}", self.name), self.name.span())
    }
    pub fn get_hash(&self) -> u64 {
        let mut state = DefaultHasher::new();
        self.hash(&mut state);
        state.finish()
    }
    pub fn get_merge_map_name(&self) -> syn::Ident {
        syn::Ident::new(&format!("{}_merge_map", self.name), self.name.span())
    }
    pub fn get_relation_key_target(&self) -> Option<&syn::Ident> {
        self.key.as_ref().and_then(|key| key.target.as_ref())
    }
    pub fn get_relation_key_target_type(&self) -> Option<&syn::Type> {
        self.get_relation_key_target().map(|name| {
            &self
                .parameters
                .iter()
                .find(|parameter| &parameter.name == name)
                .unwrap()
                .typ
        })
    }
    pub fn is_relation_key_target(&self, name: &syn::Ident) -> bool {
        self.key
            .as_ref()
            .and_then(|key| key.target.as_ref().map(|target_name| target_name == name))
            .unwrap_or(false)
    }
    /// Does the parameter with `name` belong to the relation key source?
    pub fn is_in_relation_key_source(&self, name: &syn::Ident) -> bool {
        self.key
            .as_ref()
            .map(|key| key.source.iter().any(|source_name| source_name == name))
            .unwrap_or(false)
    }
}

/// A wrapper around a vector of relations, so that we can implement
/// `syn::Parse` for it.
pub struct Relations {
    pub(crate) relations: Vec<Relation>,
}

impl From<Relations> for Vec<Relation> {
    fn from(rs: Relations) -> Vec<Relation> {
        rs.relations
    }
}

/// Configuration of all tables.
#[derive(Default)]
pub struct DatabaseSchema {
    pub custom_ids: Vec<CustomId>,
    pub incremental_ids: Vec<IncrementalId>,
    pub enums: Vec<Enum>,
    pub interning_tables: Vec<InterningTable>,
    pub relations: Vec<Relation>,
    /// Derived relations are not stored in the ``table`` object.
    pub derived_relations: Vec<Relation>,
}

impl DatabaseSchema {
    /// Finds the `IncrementalId` struct that generates objects of the given type.
    pub fn find_incremental_id(&self, typ: &syn::Type) -> Option<&IncrementalId> {
        if let syn::Type::Path(syn::TypePath { qself: None, path }) = typ {
            if let Some(ident) = path.get_ident() {
                for id in &self.incremental_ids {
                    if &id.name == ident {
                        return Some(id);
                    }
                }
            }
        }
        None
    }
    pub fn get_type_kind(&self, typ: &syn::Type) -> TypeKind {
        if let syn::Type::Path(syn::TypePath { qself: None, path }) = typ {
            if let Some(ident) = path.get_ident() {
                for id in &self.custom_ids {
                    if &id.name == ident {
                        return TypeKind::CustomId;
                    }
                }
                for id in &self.incremental_ids {
                    if &id.name == ident {
                        return TypeKind::IncrementalId(id);
                    }
                }
                for table in &self.interning_tables {
                    if &table.key.name == ident {
                        return TypeKind::InternedId(table);
                    }
                }
                for enum_info in &self.enums {
                    if &enum_info.item.ident == ident {
                        return TypeKind::Enum;
                    }
                }
                match ident.to_string().as_ref() {
                    "bool" | "u16" | "u32" | "u64" | "u128" | "String" => {
                        return TypeKind::RustType
                    }
                    _ => panic!("Unknown type: {:?}.", typ),
                }
            }
        }
        panic!("Type {:?} is not an identifier.", typ);
    }
    pub fn find_interning_table(&self, name: &syn::Ident) -> Option<&InterningTable> {
        for table in &self.interning_tables {
            if &table.name == name {
                return Some(table);
            }
        }
        None
    }
    pub fn find_relation(&self, name: &syn::Ident) -> Option<&Relation> {
        for relation in self.relations.iter().chain(&self.derived_relations) {
            if &relation.name == name {
                return Some(relation);
            }
        }
        None
    }
}
